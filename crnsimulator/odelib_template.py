#!/usr/bin/env python
#
# crnsimulator.odelib_template: A template for a compiled ODE solver.
# ... or an autogenerated script from the *crnsimulator* Python package
# 
# Written by Stefan Badelt (badelt@caltech.edu).
#
# Use at your own risk. 
#
#

#
# If this file is executable, it contains a system of hardcoded ODEs together
# with some default parameters. It is recommended to edit the source directly
# at "crnsimulator.odelib_template" or provide your own template file.
#
# call with: python #<&>FILENAME<&># --help
#

import argparse
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Uncomment this section for seaborn plot-style
import seaborn as sns
sns.set()
sns.set_context("notebook", font_scale=1, rc={"lines.linewidth": 2.0})

def ode_plotter(name, t, ny, svars, log=False):
  """ Plots the ODE trajectories.

  Args:
    name <str>: Name of the outputfile (supports *.pdf and *.png)
    t <list[flt]> : time units plotted on the x-axis.
    ny <list[list[flt]]> : a list of trajectories plotted on the y-axis.
    svars <list[str]>: A list of names for every trajectory in ny
    log <optional:<bool>>: Plot data on a logarithmic time scale

  Prints:
    A file containing the plot (Format *.pdf or *.png)

  Returns:
    name <str>: Name of the file containing the plot
  """
  fig, ax = plt.subplots(1, 1, figsize=(7, 3.25))

  for e, y in enumerate(ny) :
    ax.plot(t, y, '-', label=svars[e])

  ax.set_xlabel('Time [s]', fontsize=16)
  ax.set_ylabel('Concentration [M]', fontsize=16)
  if log :
    ax.set_xscale('log')
  else :
    ax.set_xscale('linear')

  plt.legend()
  fig.tight_layout()
  plt.savefig(name)
  return name

rates = {
#<&>RATES<&>#
  }

#<&>ODECALL<&>#

#<&>JACOBIAN<&>#

def add_integrator_args(parser):
  """ODE integration aruments."""

  parser.add_argument("--list", action='store_true',
      help="Print all species and exit.")

  # required: simulation time and output settings
  parser.add_argument("--t0", type=float, default=0, metavar='<flt>',
      help="First time point of the time-course.")
  parser.add_argument("--t8", type=float, default=100000, metavar='<flt>',
      help="End point of simulation time.")
  parser.add_argument("--t-lin", type=int, default=50000, metavar='<int>',
      help="Returns --t-lin evenly spaced numbers on a linear scale from --t0 to --t8.")
  parser.add_argument("--t-log", type=int, default=None, metavar='<int>',
      help="Returns --t-log evenly spaced numbers on a logarithmic scale from --t0 to --t8.")

  # required: initial concentration vector
  parser.add_argument("--p0", nargs='+', metavar='<int/str>=<flt>',
      help="Vector of initial species concentrations. " + \
          "E.g. \"--p0 1=0.5 3=0.7\" stands for 1st species at a concentration of 0.5 " + \
          "and 3rd species at a concentration of 0.7. You may chose to address species " + \
          "directly by name, e.g.: --p0 C=0.5.")

  # optional: choose output formats
  parser.add_argument("--nxy", action='store_true',
      help="Print time course in nxy format.")
  parser.add_argument("--pyplot", default='', metavar='<str>',
      help="Specify a filename to plot the ODE simulation.")

  # advanced: scipy.integrate.odeint parameters
  parser.add_argument("-a", "--atol", type=float, default=None, metavar='<flt>',
      help="Specify absolute tolerance for the solver.")
  parser.add_argument("-r", "--rtol", type=float, default=None, metavar='<flt>',
      help="Specify relative tolerance for the solver.")
  parser.add_argument("--mxstep", type=int, default=0, metavar='<int>',
      help="Maximum number of steps allowed for each integration point in t.")

  return

def integrate(args):
  """Main interface to solve the ODE-system.

  Args:
    args <argparse()>: An argparse object containing all of the arguments as specified above
      (crnsimulator.add_integrator_args)

  Prints:
    - verbose information
    - plot files
    - time-course
      
  Returns:
    Nothing
  """

  #<&>SORTEDVARS<&>#

  p0 = [0] * len(svars)
  #<&>DEFAULTCONCENTRATIONS<&>#

  if args.list :
    for e, v in enumerate(svars, 1) :
      print '#', e, v
    raise SystemExit('# Specify a vector of initial concentrations: ' + \
          'e.g. --p0 1=0.1 2=0.005 3=1e-6 (see --help)')

  if not args.nxy and not args.pyplot :
    print Warning('# Use --pyplot and/or --nxy to plot your results.')

  if not args.t8 :
    raise ValueError('Specify a valid end-time for the simulation: --t8 <flt>')

  if args.t_log :
    if args.t0 == 0 :
      raise ValueError('--t0 cannot be 0 when using log-scale!')
    time = np.logspace(np.log10(args.t0), np.log10(args.t8), num=args.t_log)
  elif args.t_lin :
    time = np.linspace(args.t0, args.t8, num=args.t_lin)
  else :
    raise ValueError('Please specify either --t-lin or --t-log. (see --help)')

  if not args.p0 :
    print '# Initial concentrations:', zip(svars,p0)
    if sum(p0) == 0 :
      for e, v in enumerate(svars, 1) :
        print '#', e, v
      raise SystemExit('# -- Must specify a vector of initial concentrations: ' + \
          'e.g. --p0 1=0.1 2=0.005 3=1e-6 (see --help)')
  else :
    for term in args.p0 :
      p,o = term.split('=')
      try :
        pi  = svars.index(p)
      except ValueError, e: 
        pi = int(p)-1
      finally:
        p0[pi] = float(o)
    print '# Initial concentrations:', zip(svars,p0)

  # TODO: It would be nice if it is possible to read alternative rates from a file instead.
  # None triggers the default-rates that are hard-coded in the (this) library file.
  rates = None

  ny = odeint(#<&>ODENAME<&>#, 
      p0, time, (rates, ), #<&>JCALL<&>#,
      atol=args.atol, rtol=args.rtol, mxstep=args.mxstep).T

  if args.nxy :
    for i in zip(time, *ny):
      print ' '.join(map("{:.9e}".format, i))

  if args.pyplot :
    plotfile = ode_plotter(args.pyplot, time, ny, svars, log=True if args.t_log else False)
    print '# Printed file:', plotfile
  
if __name__ == '__main__':
  parser = argparse.ArgumentParser(
      formatter_class=argparse.ArgumentDefaultsHelpFormatter)

  add_integrator_args(parser)

  args = parser.parse_args()

  integrate(args)

